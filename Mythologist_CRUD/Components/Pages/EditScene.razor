@page "/editscene/{sceneName}"
@using Azure.Storage.Blobs
@using Mythologist_CRUD.Utils
@using SharedLogic.Services
@using SharedLogic.Model
@using System.ComponentModel.DataAnnotations
@using System.Net
@using System.Globalization
@using SharedLogic.Utils

@inject IDatabaseConnectionService dbConnection
@inject IDataValidatorService dataValidator
@inject NavigationManager NavManager
@inject Blazored.SessionStorage.ISessionStorageService sessionStorage
@inject IConfiguration configuration
@inject ISnackbar Snackbar

@if (scene == null)
{
    <MudText>Scene `@sceneName` not found</MudText>
}
else {
    <MudContainer MaxWidth="MaxWidth.Medium">
        <MudStack>
            <MudText>Editing Scene `@sceneName`</MudText>
            <MudForm @bind-IsValid="@success">
                <MudGrid Justify="Justify.Center">
                    <MudItem xs="12">
                    <MudTextField @bind-Value="renamedScene" Label="Scene Name" Variant="Variant.Filled"></MudTextField>
                    </MudItem>
                    <MudItem xs="6">
                        <MudSelect T="BlobUtils.MediaMetadata" @bind-Value=SelectedBackgroundAudio @bind-Value:after="ForceAudioRefresh" Label="Background Audio" Variant="Variant.Filled" Validation="@(new Func<BlobUtils.MediaMetadata, string>(ValidateMediaDropdown))">
                            <MudSelectItem T="BlobUtils.MediaMetadata" Value="@(null)">No Audio</MudSelectItem>
                            @foreach (BlobUtils.MediaMetadata item in allAvailableAudioMedia)
                            {
                                <MudSelectItem Value="@item" />
                            }
                        </MudSelect>
                    </MudItem>
                    <MudItem xs="6" Style="align-self: center;">
                        <audio @key="@forceAudioUpdate" id="audio-player" controls style="display: flex; margin-left: auto; margin-right: auto; align-self: center;">
                            <source src="@SelectedBackgroundAudio?.FullUrl">
                            Your browser does not support the audio element.
                        </audio>
                    </MudItem>
                    <MudItem xs="12">
                    <MudSelect T="BlobUtils.MediaMetadata" @bind-Value=SelectedBackgroundImage Label="Background Image" Variant="Variant.Filled" Validation="@(new Func<BlobUtils.MediaMetadata, string>(ValidateMediaDropdown))">
                        <MudSelectItem T="BlobUtils.MediaMetadata" Value="@(null)">No Image</MudSelectItem>
                        @foreach (BlobUtils.MediaMetadata item in allAvailableImageMedia)
                        {
                            <MudSelectItem Value="@item" />
                        }
                    </MudSelect>
                    </MudItem>
                     <MudItem xs="12">
                    <MudPaper Height="300px" Width="100%" Class="d-flex" Style="max-height:300px; align-items: center; background: rgba(0,0,0,0.25)">
                        @if (@SelectedBackgroundImage != null)
                        {
                            <MudImage Src=@SelectedBackgroundImage?.FullUrl Fluid="true" ObjectFit="ObjectFit.Contain" Style="max-height:300px; display: block; margin-left: auto; margin-right: auto;"></MudImage>
                        }
                    </MudPaper>
                    </MudItem>
                </MudGrid>
            </MudForm>
            <MudStack Class="d-flex align-center ">
                <MudStack Row="true">
                    <MudButton @onclick="BackToSceneList" Variant="Variant.Filled" Color="Color.Secondary" Class="ml-auto">Back</MudButton>
                    <MudButton @onclick="SubmitForm" Variant="Variant.Filled" Color="Color.Primary" Disabled="@(!success)" Class="ml-auto">Save</MudButton>
                </MudStack>
            </MudStack>
        </MudStack>
    </MudContainer>
}
@code {

    //By "wrappedAttribute" we mean that Validation can take an Attribute type directly, but we're using a function that used the attribute cause we wanna append extra checks
    private string ValidateMediaDropdown(BlobUtils.MediaMetadata value)
    {
        // A validator is good if it returns null, otherwise return a string that is the error you want to display on the form
        // At the moment, all is good, but leaving this setup cause i'll forget
        return null;
    }

    bool success;
    [Parameter]
    public string? sceneName { get; set; }
    private string renamedScene;

    private string? gameName;

    private SceneModel? scene;

    private BlobServiceClient? blobServiceClient;
    private BlobContainerClient? gameContainer;

    public BlobUtils.MediaMetadata? SelectedBackgroundImage { get; set; }
    public BlobUtils.MediaMetadata? SelectedBackgroundAudio { get; set; }

    // The media available to the user, that they've uploaded.
    private List<BlobUtils.MediaMetadata> allAvailableImageMedia = new List<BlobUtils.MediaMetadata>();
    private List<BlobUtils.MediaMetadata> allAvailableAudioMedia = new List<BlobUtils.MediaMetadata>();

    //Weird hack. To get at the audio element (raw html), it needs a property on its root element that changes to force a rebuild
    //This being an int dosen't matter, it just needs to change.
    private int forceAudioUpdate = 0;

    protected async override Task OnInitializedAsync()
    {
        gameName = await sessionStorage.GetItemAsync<string>("GameName");
        var GMPassword = await sessionStorage.GetItemAsync<string>("GMPassword");

        if (gameName == null)
        {
            Snackbar.Add("Couldn't find game, redirecting.");
            NavManager.NavigateTo("/");
            return;
        }

        bool verified = await dbConnection.VerifyLogin(gameName, GMPassword);
        if (!verified)
        {
            Snackbar.Add("Not authorized to be here. The authorities have been informed.");
            NavManager.NavigateTo("/");
            return;
        }

        scene = dbConnection.AllScenes().Find(x => x.id == sceneName);

        //Grab the metadata for all the media we can set in this panel
        (blobServiceClient, gameContainer) = await BlobUtils.SetupOrVerifyBlobStorageGumph(gameName, configuration.GetConnectionString("blobStorage")!, blobServiceClient, gameContainer);
        var getAllImagesTask = BlobUtils.GetMediaMetaData(gameName, SharedLogic.Utils.Constants.MediaItemType.Image, gameContainer, blobServiceClient);
        var getAllAudioTask = BlobUtils.GetMediaMetaData(gameName, SharedLogic.Utils.Constants.MediaItemType.Audio, gameContainer, blobServiceClient);
        var imagesAndAudio = await Task.WhenAll(getAllImagesTask, getAllAudioTask);
        allAvailableImageMedia = imagesAndAudio[0];
        allAvailableAudioMedia = imagesAndAudio[1];

        //Set the dropdowns to what the database says
        if (scene != null)
        {
            //Just taken from the passed in param. Sets the textedit.
            renamedScene = sceneName;

            if (scene.backgroundImageUri != null)
            {
                var fileName = Path.GetFileName(scene.backgroundImageUri.AbsolutePath);
                SelectedBackgroundImage = allAvailableImageMedia.Find(x => x.Name == fileName);
                if (SelectedBackgroundImage == null)
                {
                    Snackbar.Add($"Couldn't find media for database reported background image '{fileName}'. Perhaps it has been deleted?");
                }
            }
            if (scene.backgroundMusicUri != null)
            {
                var fileName = Path.GetFileName(scene.backgroundMusicUri.AbsolutePath);
                SelectedBackgroundAudio = allAvailableAudioMedia.Find(x => x.Name == fileName);

                if (SelectedBackgroundAudio == null)
                {
                    Snackbar.Add($"Couldn't find media for database reported background audio '{fileName}'. Perhaps it has been deleted?");
                }
            }
        }
    }


    public async Task SubmitForm()
    {
        (blobServiceClient, gameContainer) = await BlobUtils.SetupOrVerifyBlobStorageGumph(gameName, configuration.GetConnectionString("blobStorage")!, blobServiceClient, gameContainer);

        if (sceneName != renamedScene)
        {
            await dbConnection.RenameScene(gameName, scene!, renamedScene);
        }

        SceneModel updatedScene = scene!;
        updatedScene.backgroundImageUri = SelectedBackgroundImage != null ? BlobUtils.MakeFullStorageUri(blobServiceClient, gameName, Constants.MediaItemType.Image, SelectedBackgroundImage.Name) : null;
        updatedScene.backgroundMusicUri = SelectedBackgroundAudio != null ? BlobUtils.MakeFullStorageUri(blobServiceClient, gameName, Constants.MediaItemType.Audio, SelectedBackgroundAudio.Name) : null;

        await dbConnection.UpdateScene(gameName, updatedScene);
        BackToSceneList();
    }

    public void BackToSceneList()
    {
        NavManager.NavigateTo("/scenelist");
    }

    private void ForceAudioRefresh()
    {
        forceAudioUpdate++;
    }

}